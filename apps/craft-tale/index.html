<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Створи казку</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Open Sans', sans-serif;
      background-color: #f8f4ff;
    }
    h1, h2, h3 {
      font-family: 'Playfair Display', serif;
    }
    .fairy-bg {
      background: linear-gradient(135deg, #c2e9fb 0%, #a1c4fd 100%);
    }
    .typing-effect::after {
      content: '|';
      animation: blink 1s step-end infinite;
    }
    @keyframes blink {
      from, to { opacity: 1; }
      50% { opacity: 0; }
    }
    /* Magical button and input styles */
    .magical-input {
      border: 2px solid #a1c4fd;
      border-radius: 0.5rem;
      background-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 8px rgba(161, 196, 253, 0.5);
      transition: all 0.3s ease;
    }
    .magical-input:focus {
      border-color: #c2e9fb;
      box-shadow: 0 0 12px rgba(161, 196, 253, 0.8);
      outline: none;
    }
    .magical-button {
      background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
      border-radius: 0.5rem;
      color: #fff;
      font-weight: 600;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
    }
    .magical-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 7px 14px rgba(50, 50, 93, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
    }
    .magical-button:active {
      transform: translateY(1px);
    }
    .floating {
      animation: floating 3s ease-in-out infinite;
    }
    @keyframes floating {
      0% { transform: translate(0, 0px); }
      50% { transform: translate(0, 15px); }
      100% { transform: translate(0, 0px); }
    }
    .story-container {
      max-height: 70vh;
      overflow-y: auto;
      border-radius: 0.5rem;
      scroll-behavior: smooth;
      background-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
    }
    .story-container::-webkit-scrollbar {
      width: 8px;
    }
    .story-container::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    .story-container::-webkit-scrollbar-thumb {
      background: #a1c4fd;
      border-radius: 4px;
    }
    .story-container::-webkit-scrollbar-thumb:hover {
      background: #8bb3fc;
    }
    /* Loading animation */
    .loading-dots span {
      animation: bounce 1.5s infinite;
    }
    .loading-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }
    .loading-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
  </style>
</head>
<body class="min-h-screen fairy-bg">
  <div class="container mx-auto p-4 flex flex-col h-screen">
    <!-- Header -->
    <header class="text-center my-4 relative">
      <h1 class="text-3xl md:text-5xl font-bold text-indigo-900 mb-2">Створи свою казку</h1>
      <p class="text-lg text-indigo-700">Магічний світ чекає на тебе!</p>

      <!-- Floating illustrations -->
      <div class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden -z-10">
        <!-- Stars -->
        <svg class="absolute top-5 left-10 w-6 h-6 text-yellow-400 floating" style="animation-delay: 0.5s;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path>
        </svg>
        <svg class="absolute top-20 right-20 w-4 h-4 text-yellow-400 floating" style="animation-delay: 1s;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path>
        </svg>
        <!-- Castle -->
        <svg class="absolute bottom-5 right-5 w-12 h-12 text-indigo-800 opacity-20 floating" style="animation-delay: 0.8s;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M2 22h20V10l-6-6H8L2 10v12zM12 7V3H8v4H4v2h16V7h-4V3h-4v4h-4v2h12v2H4v2h16v2H4v2h16v2H4v2h16v-8H4V7h8z"></path>
        </svg>
      </div>
    </header>

    <!-- Main content -->
    <main class="flex-grow flex flex-col space-y-6 mt-4">
      <!-- Story creation section -->
      <div id="storyCreation" class="flex-grow flex flex-col justify-center items-center">
        <div class="max-w-lg w-full text-center">
          <h2 class="text-2xl font-bold text-indigo-800 mb-6">Розпочни подорож у світ казок</h2>
          <p class="mb-8">Натисни кнопку, щоб розпочати створення унікальної казки з допомогою штучного інтелекту</p>
          <button id="startStoryBtn" class="magical-button px-8 py-4 text-lg">Створити казку</button>
        </div>
      </div>

      <!-- Interaction section (hidden by default) -->
      <div id="interactionSection" class="hidden flex-grow flex flex-col justify-between">
        <div class="flex-grow mb-4">
          <div class="story-container p-6 mb-6">
            <div id="conversationContainer" class="space-y-6">
              <!-- Conversation will be displayed here -->
            </div>
          </div>
        </div>

        <div class="flex space-x-4">
          <input id="userInput" type="text" placeholder="Напишіть свою відповідь тут..." class="magical-input flex-grow px-4 py-3 text-gray-700" />
          <button id="submitBtn" class="magical-button px-6 py-3">Відправити</button>
        </div>
      </div>

      <!-- Final story display (hidden by default) -->
      <div id="finalStory" class="hidden flex-grow flex flex-col">
        <div class="story-container p-6 mb-6 flex-grow">
          <h2 class="text-2xl font-bold text-indigo-800 mb-4">Ваша казка:</h2>
          <div id="storyContent" class="prose max-w-none">
            <!-- Final story will be displayed here -->
          </div>
        </div>

        <div class="flex justify-center space-x-4">
          <button id="newStoryBtn" class="magical-button px-6 py-3">Нова казка</button>
          <button id="printStoryBtn" class="magical-button px-6 py-3">Роздрукувати</button>
        </div>
      </div>

      <!-- Loading indicator (hidden by default) -->
      <div id="loadingIndicator" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
          <h3 class="text-xl mb-4">Створюємо казку</h3>
          <div class="loading-dots text-3xl text-indigo-600">
            <span>•</span>
            <span>•</span>
            <span>•</span>
          </div>
        </div>
      </div>
    </main>

    <!-- Footer -->
    <footer class="py-4 text-center text-indigo-700">
      <p>© 2024 Чарівна казка</p>
    </footer>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Get API key from URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const apiKey = urlParams.get('apiKey');

      if (!apiKey) {
        alert('Необхідно вказати API ключ для роботи додатку');
        return;
      }

      // DOM Elements
      const storyCreation = document.getElementById('storyCreation');
      const interactionSection = document.getElementById('interactionSection');
      const finalStory = document.getElementById('finalStory');
      const startStoryBtn = document.getElementById('startStoryBtn');
      const userInput = document.getElementById('userInput');
      const submitBtn = document.getElementById('submitBtn');
      const conversationContainer = document.getElementById('conversationContainer');
      const storyContent = document.getElementById('storyContent');
      const newStoryBtn = document.getElementById('newStoryBtn');
      const printStoryBtn = document.getElementById('printStoryBtn');
      const loadingIndicator = document.getElementById('loadingIndicator');

      // Gemini API conversation state
      let conversationHistory = [];
      let isStoryFinished = false;

      // System instruction for Gemini
      const systemInstruction = `# **Interactive Fairy Tale Assistant – Instructions**

## **Objective**
You are an advanced storytelling assistant tasked with creating a **personalized, high-quality fairy tale** for **kindergarten-aged children (4-6 years old)**. The process consists of two key phases:

1. **Interactive Questioning Phase** – Collecting information dynamically through structured Q&A.
2. **Fairy Tale Generation Phase** – Crafting a rich, immersive fairy tale using the best literary techniques.

The story should be written in **Ukrainian** and use **high-quality narrative techniques inspired by great literary works**.

---

## **Phase 1: Interactive Questioning (User Input Collection)**

### **Rules for Questioning**
- **Begin by stating**:
  *"Я поставлю вам кілька запитань, щоб створити чарівну казку саме для вас! Я буду ставити два запитання за раз. Почнемо!"*
- **Start with one predefined question:**
  *"Хто буде головним героєм або героями вашої казки?"*
- **After each response, analyze the answer and generate the next question dynamically** to ensure consistency and depth.
- **Never ask more than 2 questions per round.**
- **Ask a mix of descriptive and yes/no questions**:
  - **10-15 Descriptive Questions** – To define characters, setting, conflicts, magical elements, and themes.
  - **5-8 Yes/No Questions** – To confirm specific preferences.
- **Adjust future questions based on previous answers** to ensure coherence and depth.
- **Once all necessary details are collected, conclude with**:
  *"Дякую! Тепер у мене є все необхідне, щоб створити вашу особливу казку!"*

---

### **Guidelines for Asking Questions Dynamically**
#### **1. Character Development (Main & Supporting Characters)**
- Identify **all main characters**: Who are they? Are there multiple protagonists?
- **Use deep characterization techniques**:
  - **Internal Motivation**: What do they desire? (e.g., finding a treasure, reuniting with a loved one, discovering a secret).
  - **Strengths & Weaknesses**: What are they good at? What challenges them?
  - **Emotional Core**: What makes them happy? What makes them sad or afraid?
  - **Character Relationships**: Are they siblings? Best friends? A group of magical creatures?

#### **2. Setting & World-Building**
- Where does the story take place?
  - **Types of worlds**: Enchanted forest, underwater city, a kingdom in the clouds, a land made of sweets, etc.
  - **Atmosphere & Mood**: Warm and friendly, mysterious and magical, exciting and adventurous.
  - **Sensory Elements**: What are the sights, sounds, and scents of this world?

#### **3. Supporting Characters & Magical Companions**
- Does the main character have a friend, guide, or sidekick?
- Should the story include talking animals, fairies, dragons, or other creatures?
- How do these characters **help or challenge** the protagonist?

#### **4. Conflict & Adventure**
- What problem or adventure drives the story?
  - A **lost object** (e.g., a golden key, a forgotten map).
  - A **mission** (e.g., saving someone, delivering a message).
  - A **magical challenge** (e.g., breaking a spell, solving a mystery).
- Who or what creates the **main conflict**?
  - A mischievous trickster?
  - A magical riddle?
  - A misunderstood "villain"?

#### **5. Magical Elements**
- Should the story include **enchanted objects**? (e.g., a glowing book, a crystal ball, an invisible cloak).
- Do **magic rules** exist? (e.g., only three wishes, spells can only be cast at sunrise).

#### **6. Resolution & Ending**
- How should the story end?
  - A **happy and funny conclusion**?
  - A **lesson learned**?
  - A **surprise twist**?

#### **7. Moral & Lesson**
- What message should the story convey?
  - **Kindness overcomes everything**.
  - **Bravery in the face of fear**.
  - **True magic comes from friendship**.

---

## **Phase 2: Fairy Tale Generation (Writing the Story)**
Once the questioning phase is complete, generate a **beautifully written fairy tale** in **Ukrainian**, applying the best literary techniques.

### **Fairy Tale Structure**
**1. Captivating Introduction** – *Set up the world and introduce the main character(s).*
- Use **evocative opening lines** that **instantly immerse** the reader in the magical world.
- Establish the protagonist's normal life before the adventure begins.
- Foreshadow the upcoming journey.

**2. Inciting Incident** – *What propels the characters into their adventure?*
- Something **unexpected happens** (e.g., a mysterious letter, a disappearing castle).
- The protagonist is given a **choice or a mission**.

**3. Rising Action** – *The journey begins, introducing challenges and companions.*
- **Encounters with magical beings** (mentors, tricksters, friends).
- **First major challenge** – A small trial that tests their abilities.
- **Second challenge** – A deeper test of character, courage, or wit.

**4. Climax** – *The biggest challenge or moment of decision.*
- The protagonist must use **wisdom, kindness, or bravery** to overcome the final obstacle.
- **A moment of realization** where the main lesson is revealed.

**5. Resolution** – *A satisfying and magical conclusion.*
- A **heartwarming reunion, a fulfilled wish, or a surprising twist**.
- Reinforce the **moral** in an engaging way.

---

## **Advanced Literary Techniques for Best Results**
1. **"Show, Don't Tell"**
   - Instead of *"The forest was magical,"* describe it:
     *"Густий ліс світився срібним світлом, а вітерець шепотів казкові історії у верхівках дерев."*

2. **Use Repetition & Rhythm** *(Great for young readers.)*
   - *"Крап-крап, крап-крап, маленький гном біг до чарівного мосту."*

3. **Create Fun Dialogue** *(Talking animals, rhyming speech, playful language.)*
   - *"Ой-ой-ой!" — вигукнув гоблін. "Ти мусиш знайти ключ до заходу сонця, інакше двері зникнуть!"*

4. **Use Onomatopoeia & Sound Effects** *(Makes the story exciting.)*
   - *БАХ! Двері зачинилися за чарівником!*
   - *Шурх-шурх! Листя захиталося від вітру.*

5. **Keep Sentences Short & Engaging** *(Easier for young children to follow.)*
   - Avoid overly complex phrases.
   - Use **fun, playful, and rhythmic language**.

6. **End on a Magical or Heartwarming Note**
   - A **funny surprise** (*"А з того дня дракон чхав тільки блискітками!"*).
   - A **gentle lesson** (*"І ось так, Марічка дізналася, що справжня магія — це доброта."*).
   - A **dreamy ending** (*"І якщо ти прислухаєшся, можливо, вітер ще досі розповідає цю казку."*).

---

## **Final Notes**
- **Do NOT generate the story until all questions are answered.**
- **Do NOT include any notes or explanations in the final output—only the completed fairy tale.**
- Ensure the final story is **enchanting, beautifully written, and full of child-friendly magic**.
- The story must be written **entirely in Ukrainian**.`;

      // Helper for creating message elements
      function createMessageElement(role, text) {
        const messageDiv = document.createElement('div');
        messageDiv.className = role === 'user' ? 'bg-indigo-100 p-4 rounded-lg' : 'bg-white p-4 rounded-lg border-l-4 border-indigo-500';

        const content = document.createElement('p');
        content.className = 'whitespace-pre-wrap';
        content.textContent = text;

        messageDiv.appendChild(content);
        return messageDiv;
      }

      // Display typing effect for AI responses
      function displayWithTypingEffect(element, text, speed = 30) {
        return new Promise(resolve => {
          element.classList.add('typing-effect');
          let i = 0;
          element.textContent = '';

          function typeNextChar() {
            if (i < text.length) {
              element.textContent += text.charAt(i);
              i++;
              setTimeout(typeNextChar, speed);
            } else {
              element.classList.remove('typing-effect');
              resolve();
            }
          }

          typeNextChar();
        });
      }

      // Function to send message to Gemini API
      async function sendMessageToGemini(userMessage) {
        try {
          showLoading(true);

          // Build conversation history for API request
          let apiConversation = conversationHistory.map(msg => ({
            role: msg.role,
            parts: [{ text: msg.text }]
          }));

          // Add new user message
          apiConversation.push({
            role: 'user',
            parts: [{ text: userMessage }]
          });

          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: apiConversation,
              systemInstruction: {
                role: 'user',
                parts: [{ text: systemInstruction }]
              },
              generationConfig: {
                temperature: 1,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 8192,
                responseMimeType: "text/plain"
              }
            })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          }

          // Check if data has the expected structure
          if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts) {
            throw new Error('Unexpected API response format');
          }

          const aiMessage = data.candidates[0].content.parts[0].text;

          // Update conversation history
          conversationHistory.push({
            role: 'user',
            text: userMessage
          });

          conversationHistory.push({
            role: 'model',
            text: aiMessage
          });

          return aiMessage;

        } catch (error) {
          console.error('Error sending message to Gemini API:', error);
          alert(`Помилка: ${error.message}`);
          return null;
        } finally {
          showLoading(false);
        }
      }

      // Show/hide loading indicator
      function showLoading(show) {
        loadingIndicator.classList.toggle('hidden', !show);
      }

      // Start the conversation
      async function startConversation() {
        storyCreation.classList.add('hidden');
        interactionSection.classList.remove('hidden');

        // Initialize conversation
        conversationHistory = [];

        // Initial message
        const initialMessage = "Я поставлю вам кілька запитань, щоб створити чарівну казку саме для вас! Я буду ставити два запитання за раз. Почнемо!\n\nХто буде головним героєм або героями вашої казки?";

        // Add to conversation history
        conversationHistory.push({
          role: 'model',
          text: initialMessage
        });

        // Display initial message
        const messageElement = createMessageElement('model', initialMessage);
        conversationContainer.appendChild(messageElement);

        // Create paragraph for typing effect
        const paragraph = messageElement.querySelector('p');
        await displayWithTypingEffect(paragraph, initialMessage);

        // Focus input field
        userInput.focus();
      }

      // Check if the AI message indicates completion of story gathering
      function checkForStoryCompletion(message) {
        const completionPhrases = [
          "Дякую! Тепер у мене є все необхідне",
          "тепер я можу створити вашу особливу казку",
          "розпочинаю створення казки",
          "зараз створю вашу унікальну казку"
        ];

        return completionPhrases.some(phrase => message.toLowerCase().includes(phrase.toLowerCase()));
      }

      // Handle user input submission
      async function handleUserInput() {
        const message = userInput.value.trim();
        if (!message) return;

        // Clear input
        userInput.value = '';

        // Display user message
        const userMessageElement = createMessageElement('user', message);
        conversationContainer.appendChild(userMessageElement);

        // Get AI response
        const aiResponse = await sendMessageToGemini(message);

        if (aiResponse) {
          // Display AI message
          const aiMessageElement = createMessageElement('model', aiResponse);
          conversationContainer.appendChild(aiMessageElement);

          // Add typing effect
          const paragraph = aiMessageElement.querySelector('p');
          await displayWithTypingEffect(paragraph, aiResponse);

          // Scroll to latest message
          conversationContainer.scrollTop = conversationContainer.scrollHeight;

          // Check if story gathering is complete
          if (checkForStoryCompletion(aiResponse)) {
            // Generate the final story
            await generateFinalStory();
          }
        }
      }

      // Generate the final story
      async function generateFinalStory() {
        showLoading(true);

        try {
          // Add a final prompt to generate the story
          const finalPrompt = "Дякую за відповіді! Будь ласка, створи зараз повну казку на основі наших відповідей. Напиши лише саму казку, без додаткових коментарів чи пояснень. Казка має бути українською мовою, з гарною структурою і цікавими літературними прийомами. Очікую на чудову казку!";

          const finalStoryResponse = await sendMessageToGemini(finalPrompt);

          if (finalStoryResponse) {
            // Hide interaction section and show final story
            interactionSection.classList.add('hidden');
            finalStory.classList.remove('hidden');

            // Format and display the story
            storyContent.innerHTML = finalStoryResponse
              .split('\n')
              .map(line => line.trim() ? `<p>${line}</p>` : '<br>')
              .join('');

            // Set flag for completed story
            isStoryFinished = true;
          }
        } catch (error) {
          console.error('Error generating final story:', error);
          alert('Помилка при створенні казки. Спробуйте знову.');
        } finally {
          showLoading(false);
        }
      }

      // Event listeners
      startStoryBtn.addEventListener('click', startConversation);

      submitBtn.addEventListener('click', handleUserInput);

      userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          handleUserInput();
        }
      });

      newStoryBtn.addEventListener('click', () => {
        // Reset state and show initial screen
        conversationHistory = [];
        isStoryFinished = false;
        conversationContainer.innerHTML = '';
        storyContent.innerHTML = '';
        finalStory.classList.add('hidden');
        storyCreation.classList.remove('hidden');
      });

      printStoryBtn.addEventListener('click', () => {
        // Open print dialog
        const printWindow = window.open('', '_blank');
        printWindow.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Моя казка</title>
            <style>
              body { font-family: 'Times New Roman', serif; line-height: 1.5; margin: 2cm; }
              h1 { text-align: center; margin-bottom: 1cm; }
              p { text-indent: 1cm; margin-bottom: 0.5cm; }
            </style>
          </head>
          <body>
            <h1>Моя казка</h1>
            ${storyContent.innerHTML}
          </body>
          </html>
        `);
        printWindow.document.close();
        printWindow.print();
      });
    });
  </script>
</body>
</html>